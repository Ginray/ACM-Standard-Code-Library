~~~
include<stdio.h>

include<string.h>

include<stdlib.h>

define maxn 50

int a[maxn],e[maxn];

int n;

void swap (int &a,int &b)

{

    a^=b;
    b^=a;
    a^=b;

}

struct matrix 

{

    int mp[maxn][maxn];

    void rswap (int x,int y)
    {
    for (int i=1;i<=n+1;i++)
    	swap(mp[x][i],mp[y][i]);
    
    }
    
    void relax (int x,int y)
    {
    for (int i=1;i<=n+1;i++)
    	mp[y][i]^=mp[x][i];
    
    }
    void init ()
    {
     memset(mp,0,sizeof(mp));  
        for(int i = 1; i <= n ;i++)//自己可以改变自己  
            mp[i][i] = 1;  
    }

}M;

void gauss()

{

 int i,j,k,ptr;

     for(i = 1, j= 1; j <= n; ++i, ++j)
     {
    		
    									//形成行阶梯型矩阵，从第一行第一列开始，逐列递增  
        for(ptr = i; ptr  <= n ; ptr++)
    	{							 //找出第一个是非零元的行  
            if(M.mp[ptr][j])
    		{  
                break;  
            }  
        }  
        if(ptr == n+1)
    	{                           
            --i;  
            continue;  
        }  
        if(ptr != i)
    	{                        //如果第一个是非零元的行不是当前行，则与其互换位置  
            M.rswap(ptr,i);  
        }  
        for(k = i+1; k <= n; k++ )
    	{                               //用当前的行当前列的值对下面所有行当前列的值进行消除，使其为0，以满足行阶梯型  
           if(!M.mp[k][j])
    		{                      //如果是0，则跳过  
                continue;  
            }  
            M.relax(i,k);                  //不是，则消除。  
        }  
    }  
    for( k = i; k <= n; k++)
    {                                      //处理完所有列（为n，n+1为答案列不用计算）之后，也就是现在mp数组就是行阶梯型了，那么看零行的答案是否都为0，有不为0，即是无解。  
        if(M.mp[k][n+1] != 0)
    	{  
            printf("Oh,it's impossible~!!\n");  
            return ;  
        }  
    }  
      
    printf("%d\n",1<<(n-i+1));               //有多少零行就有多少自由元，输出结果  
    return;  

}  



~~~

